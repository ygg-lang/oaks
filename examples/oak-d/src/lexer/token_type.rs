use oak_core::{Token, TokenType, UniversalTokenRole};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

pub type DToken = Token<DTokenType>;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum DTokenType {
    Root,
    Module,
    Declaration,
    Statement,
    Expression,
    Type,
    Aggregate,
    Import,
    ModuleKeyword,
    ImportKeyword,
    PublicKeyword,
    PrivateKeyword,
    ProtectedKeyword,
    PackageKeyword,
    ExportKeyword,
    StaticKeyword,
    FinalKeyword,
    AbstractKeyword,
    OverrideKeyword,
    SynchronizedKeyword,
    ConstKeyword,
    ImmutableKeyword,
    InoutKeyword,
    SharedKeyword,
    ClassKeyword,
    StructKeyword,
    InterfaceKeyword,
    UnionKeyword,
    EnumKeyword,
    FunctionKeyword,
    DelegateKeyword,
    IfKeyword,
    ElseKeyword,
    WhileKeyword,
    ForKeyword,
    ForeachKeyword,
    DoKeyword,
    SwitchKeyword,
    CaseKeyword,
    DefaultKeyword,
    BreakKeyword,
    ContinueKeyword,
    ReturnKeyword,
    GotoKeyword,
    TryKeyword,
    CatchKeyword,
    FinallyKeyword,
    ThrowKeyword,
    ScopeKeyword,
    WithKeyword,
    SynchronizedKeyword2,
    AsmKeyword,
    MixinKeyword,
    TemplateKeyword,
    ThisKeyword,
    SuperKeyword,
    NullKeyword,
    TrueKeyword,
    FalseKeyword,
    CastKeyword,
    NewKeyword,
    DeleteKeyword,
    TypeofKeyword,
    TypeidKeyword,
    IsKeyword,
    InKeyword,
    OutKeyword,
    RefKeyword,
    LazyKeyword,
    AutoKeyword,
    AliasKeyword,
    TypedefKeyword,
    ExternKeyword,
    PureKeyword,
    NothrowKeyword,
    SafeKeyword,
    TrustedKeyword,
    SystemKeyword,
    NogcKeyword,
    PropertyKeyword,
    DisableKeyword,
    DeprecatedKeyword,
    VersionKeyword,
    DebugKeyword,
    UnitTestKeyword,
    InvariantKeyword,
    BodyKeyword,
    PragmaKeyword,
    AlignKeyword,
    VoidType,
    BoolType,
    ByteType,
    UbyteType,
    ShortType,
    UshortType,
    IntType,
    UintType,
    LongType,
    UlongType,
    CentType,
    UcentType,
    FloatType,
    DoubleType,
    RealType,
    IfloatType,
    IdoubleType,
    IrealType,
    CfloatType,
    CdoubleType,
    CrealType,
    CharType,
    WcharType,
    DcharType,
    StringType,
    WstringType,
    DstringType,
    Plus,
    Minus,
    Multiply,
    Divide,
    Modulo,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNot,
    LeftShift,
    RightShift,
    UnsignedRightShift,
    Equal,
    NotEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Identity,
    NotIdentity,
    Assign,
    PlusAssign,
    MinusAssign,
    MultiplyAssign,
    DivideAssign,
    ModuloAssign,
    BitwiseAndAssign,
    BitwiseOrAssign,
    BitwiseXorAssign,
    LeftShiftAssign,
    RightShiftAssign,
    UnsignedRightShiftAssign,
    ConcatenateAssign,
    LogicalAnd,
    LogicalOr,
    Increment,
    Decrement,
    Not,
    Question,
    Dollar,
    At,
    LeftParen,
    RightParen,
    LeftBracket,
    RightBracket,
    LeftBrace,
    RightBrace,
    Semicolon,
    Comma,
    Dot,
    DotDot,
    DotDotDot,
    Colon,
    Arrow,
    Hash,
    IntegerLiteral,
    FloatLiteral,
    StringLiteral,
    CharLiteral,
    Identifier,
    LineComment,
    BlockComment,
    NestedComment,
    Whitespace,
    Newline,
    Eof,
    Error,
}

impl TokenType for DTokenType {
    type Role = UniversalTokenRole;
    const END_OF_STREAM: Self = Self::Eof;

    fn is_ignored(&self) -> bool {
        matches!(self, Self::Whitespace | Self::Newline | Self::LineComment | Self::BlockComment)
    }

    fn role(&self) -> Self::Role {
        match self {
            Self::Whitespace => UniversalTokenRole::Whitespace,
            Self::Newline => UniversalTokenRole::Whitespace,
            Self::LineComment => UniversalTokenRole::Comment,
            Self::BlockComment => UniversalTokenRole::Comment,
            Self::Eof => UniversalTokenRole::Eof,
            Self::Error => UniversalTokenRole::Error,
            _ => UniversalTokenRole::None,
        }
    }
}
